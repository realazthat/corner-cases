<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>corner-cases/cubelib Reference Documentation &mdash; corner-cases NONE documentation</title>
    
    <link rel="stylesheet" href="_static/mydoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     'NONE',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="corner-cases NONE documentation" href="index.html" />
    <link rel="next" title="cubelib_corner_t" href="cubelib-corner.html" />
    <link rel="prev" title="corner-cases" href="index.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>corner-cases NONE documentation</span></a></h1>
        <h2 class="heading"><span>corner-cases/cubelib Reference Documentation</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="index.html">corner-cases</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="cubelib-corner.html">cubelib_corner_t</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="corner-cases-cubelib-reference-documentation">
<h1>corner-cases/cubelib Reference Documentation<a class="headerlink" href="#corner-cases-cubelib-reference-documentation" title="Permalink to this headline">¶</a></h1>
<p><strong>CDEF:</strong></p>
<ul class="simple">
<li><strong>C</strong>orners</li>
<li><strong>D</strong>irections</li>
<li><strong>E</strong>dges</li>
<li><strong>F</strong>aces</li>
</ul>
<div class="section" id="cubelib-corner-t-overview">
<span id="cubelib-corner-overview"></span><h2>cubelib_corner_t Overview<a class="headerlink" href="#cubelib-corner-t-overview" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="cubelib-corner.html#c.cubelib_corner_t" title="cubelib_corner_t"><code class="xref c c-type docutils literal"><span class="pre">cubelib_corner_t</span></code></a> represents the corner of a cube.</p>
<ul class="simple">
<li>There are 8 corners in a cube.</li>
</ul>
<p>You can use it to:</p>
<ul>
<li><dl class="first docutils">
<dt>Obtain a corner via 3 unit cube coordinates, i.e coordinates in <span class="math">\(\left\{0,1\right\}^3\)</span>, such as <span class="math">\((0,0,1)\)</span> and <span class="math">\((1,0,1)\)</span>,</dt>
<dd><ul class="first last simple">
<li>Retrieve <a class="reference internal" href="cubelib-corner.html#c.cubelib_get_corner_ux" title="cubelib_get_corner_ux"><code class="xref c c-func docutils literal"><span class="pre">x</span></code></a>, <a class="reference internal" href="cubelib-corner.html#c.cubelib_get_corner_uy" title="cubelib_get_corner_uy"><code class="xref c c-func docutils literal"><span class="pre">y</span></code></a>, <a class="reference internal" href="cubelib-corner.html#c.cubelib_get_corner_uz" title="cubelib_get_corner_uz"><code class="xref c c-func docutils literal"><span class="pre">z</span></code></a> unit-cube coordinates,</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Obrain a corner via 3 origin-centered cube coordinates, i.e coordinates in <span class="math">\(\left\{-1,+1\right\}^3\)</span>,, such as <span class="math">\((-1,-1,+1)\)</span> and <span class="math">\((+1,-1,+1)\)</span>,</dt>
<dd><ul class="first last simple">
<li>Retrieve <a class="reference internal" href="cubelib-corner.html#c.cubelib_get_corner_x" title="cubelib_get_corner_x"><code class="xref c c-func docutils literal"><span class="pre">x</span></code></a>, <a class="reference internal" href="cubelib-corner.html#c.cubelib_get_corner_y" title="cubelib_get_corner_y"><code class="xref c c-func docutils literal"><span class="pre">y</span></code></a>, <a class="reference internal" href="cubelib-corner.html#c.cubelib_get_corner_z" title="cubelib_get_corner_z"><code class="xref c c-func docutils literal"><span class="pre">z</span></code></a> origin centered coordinates,</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">Obtain all (3) adjacent corners,</p>
</li>
<li><p class="first">Push a corner in a <a class="reference internal" href="#cubelib-direction-overview"><span class="std std-ref">direction</span></a>, to a neighboring corner (no wrap around),</p>
</li>
<li><p class="first">Move a corner in a <a class="reference internal" href="#cubelib-direction-overview"><span class="std std-ref">direction</span></a>, to a neighboring corner (with wrap around),</p>
</li>
<li><p class="first">Obtain adjacent (3) <a class="reference internal" href="#cubelib-face-overview"><span class="std std-ref">faces</span></a>,</p>
</li>
<li><p class="first"><span class="strikethrough">Obtain or (3) adjacent edges</span>,</p>
</li>
<li><p class="first">Obtain the opposite corner,</p>
</li>
<li><dl class="first docutils">
<dt>Retrieve an index suitable for array storage,</dt>
<dd><ul class="first last simple">
<li>The index is naturally in 3D <a class="reference external" href="https://en.wikipedia.org/wiki/Z-order_curve">morton-order</a> for the cube-space,</li>
<li>And the inverse, retrieve a corner via its index</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="cubelib-direction-t-overview">
<span id="cubelib-direction-overview"></span><h2>cubelib_direction_t Overview<a class="headerlink" href="#cubelib-direction-t-overview" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="cubelib-direction.html#c.cubelib_direction_t" title="cubelib_direction_t"><code class="xref c c-type docutils literal"><span class="pre">cubelib_direction_t</span></code></a> represents a direction in the cube.</p>
<ul class="simple">
<li>Directions and <a class="reference internal" href="#cubelib-face-overview"><span class="std std-ref">faces</span></a> are related <cite>1:1</cite>.</li>
<li>There are 6 directions for 6 faces.</li>
<li>Directions and faces and are convertible to each-other. They are separated because they intuitively separate certain functionality.</li>
</ul>
<p>Once again, you can do things like:</p>
<ul>
<li><dl class="first docutils">
<dt>Obtain a direction via 3 vector coordinates, representing the direction as a relative vector from origin</dt>
<dd><p class="first">, i.e coordinates in {0,-1,+1}^3, such as <span class="math">\((+0,0,+1)\)</span> and <span class="math">\((0,-1,0)\)</span>,</p>
<ul class="last simple">
<li>Retrieve <a class="reference internal" href="cubelib-direction.html#c.cubelib_get_direction_x" title="cubelib_get_direction_x"><code class="xref c c-func docutils literal"><span class="pre">x</span></code></a>, <a class="reference internal" href="cubelib-direction.html#c.cubelib_get_direction_y" title="cubelib_get_direction_y"><code class="xref c c-func docutils literal"><span class="pre">y</span></code></a>, <a class="reference internal" href="cubelib-direction.html#c.cubelib_get_direction_z" title="cubelib_get_direction_z"><code class="xref c c-func docutils literal"><span class="pre">z</span></code></a> vector coordinates,</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">Check if a direction is positive, i.e if it&#8217;s non-zero coordinate is positive,</p>
</li>
<li><p class="first">Obtain the opposite direction,</p>
</li>
<li></li>
<li><dl class="first docutils">
<dt>Retrieve an index suitable for array storage,</dt>
<dd><ul class="first last simple">
<li>And the inverse, retrieve a direction via its index</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">Convert it to a <a class="reference internal" href="#cubelib-face-overview"><span class="std std-ref">face</span></a>.</p>
</li>
</ul>
</div>
<div class="section" id="cubelib-edge-t-overview">
<span id="cubelib-edge-overview"></span><h2>cubelib_edge_t Overview<a class="headerlink" href="#cubelib-edge-t-overview" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="cubelib-edge.html#c.cubelib_edge_t" title="cubelib_edge_t"><code class="xref c c-type docutils literal"><span class="pre">cubelib_edge_t</span></code></a> represents the edge of a cube.</p>
<ul class="simple">
<li>There are 12 edges in a cube.</li>
</ul>
<p>You can use it to:</p>
<ul>
<li><p class="first">Obtain the lower and upper <a class="reference internal" href="#cubelib-corner-overview"><span class="std std-ref">corners</span></a> of the edge,</p>
</li>
<li><p class="first">Obtain all (4) adjacent edges,</p>
</li>
<li><p class="first">Obtain all (2) adjacent <a class="reference internal" href="#cubelib-face-overview"><span class="std std-ref">faces</span></a>,</p>
</li>
<li><p class="first">Obtain the opposite edge,</p>
</li>
<li><dl class="first docutils">
<dt>Retrieve an index suitable for array storage,</dt>
<dd><ul class="first last simple">
<li>And the inverse, retrieve a edge via its index</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="cubelib-face-t-overview">
<span id="cubelib-face-overview"></span><h2>cubelib_face_t Overview<a class="headerlink" href="#cubelib-face-t-overview" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="cubelib-face.html#c.cubelib_face_t" title="cubelib_face_t"><code class="xref c c-type docutils literal"><span class="pre">cubelib_face_t</span></code></a> represents the face of a cube.</p>
<ul class="simple">
<li>There are 6 faces in a cube.</li>
</ul>
<p>You can use it to:</p>
<ul>
<li><p class="first">Obtain the opposite face,</p>
</li>
<li><p class="first">Obtain all (4) adjacent faces,</p>
</li>
<li><p class="first">Obtain all (4) <a class="reference internal" href="#cubelib-corner-overview"><span class="std std-ref">corners</span></a> lying on the face,</p>
</li>
<li><p class="first">Obtain all (4) <a class="reference internal" href="#cubelib-edge-overview"><span class="std std-ref">edges</span></a>. lying on the face,</p>
</li>
<li><dl class="first docutils">
<dt>Retrieve an index suitable for array storage,</dt>
<dd><ul class="first last simple">
<li>And the inverse, retrieve a face via its index</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">Reason about sets of faces (using <code class="xref c c-type docutils literal"><span class="pre">cubelib_face_set_t</span></code>),</p>
</li>
<li><p class="first">Convert it to a <a class="reference internal" href="#cubelib-direction-overview"><span class="std std-ref">direction</span></a>.</p>
</li>
</ul>
</div>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cubelib/cubelib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cubelib/formatters.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="c1">//get the far corner of the cube</span>
  <span class="n">cubelib_corner_t</span> <span class="n">corner0</span> <span class="o">=</span> <span class="n">cubelib_get_corner_by_int3</span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">//one can think of the cube as having a length of 2, and lying in a 3D cartesian graph.</span>
  <span class="c1">//One can think of the cube&#39;s center lying at the origin of the space,</span>
  <span class="c1">// with the x-axis going off to the &quot;right&quot;, the y-axis going &quot;up&quot;, and the z-axis going into the</span>
  <span class="c1">// &quot;depth&quot; of space. The particulars of how you imagine this is up to you, as long as you remain consistent.</span>
  
  

  <span class="n">cubelib_corner_t</span> <span class="n">corner1</span> <span class="o">=</span> <span class="n">cubelib_get_corner_by_int3</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  
  
  <span class="c1">//corner1 and corner0 are opposite corners of the cube</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cubelib_is_corner_equal</span><span class="p">(</span><span class="n">cubelib_get_opposite_corner</span><span class="p">(</span><span class="n">corner1</span><span class="p">),</span> <span class="n">corner0</span><span class="p">));</span>
  
  <span class="c1">//&quot;push&quot; the corner to the right</span>
  <span class="n">corner1</span> <span class="o">=</span> <span class="n">cubelib_corner_push</span><span class="p">(</span><span class="n">corner1</span><span class="p">,</span> <span class="n">cubelib_get_direction_by_int3</span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  
  <span class="c1">//corner1 will now be at (+1,-1,-1)</span>
  
  
  <span class="c1">//&quot;push&quot; the corner to the right, again</span>
  <span class="n">corner1</span> <span class="o">=</span> <span class="n">cubelib_corner_push</span><span class="p">(</span><span class="n">corner1</span><span class="p">,</span> <span class="n">cubelib_get_direction_by_int3</span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  
  <span class="c1">//nothing will change, there is no where to go in that direction</span>
  <span class="c1">//corner1 will now be at (+1,-1,-1)</span>
  
  <span class="c1">//get the &quot;adjacent&quot; corner in that direction; this will wrap the corner around the to its original</span>
  <span class="c1">// value of (-1,-1,-1)</span>
  <span class="n">corner1</span> <span class="o">=</span> <span class="n">cubelib_get_adjacent_corner</span><span class="p">(</span><span class="n">corner1</span><span class="p">,</span> <span class="n">cubelib_get_direction_by_int3</span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  
  <span class="c1">//get a new corner at (+1,-1,-1)</span>
  <span class="n">cubelib_corner_t</span> <span class="n">corner2</span> <span class="o">=</span> <span class="n">cubelib_get_adjacent_corner</span><span class="p">(</span><span class="n">corner1</span><span class="p">,</span> <span class="n">cubelib_get_direction_by_int3</span><span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  
  <span class="c1">//the corners are adjacent</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cubelib_is_corner_adjacent_corner</span><span class="p">(</span><span class="n">corner1</span><span class="p">,</span> <span class="n">corner2</span><span class="p">));</span>
  
  <span class="c1">//now we can get an edge from the two adjacent corners</span>
  <span class="n">cubelib_edge_t</span> <span class="n">edge0</span> <span class="o">=</span> <span class="n">cubelib_get_edge_by_corners</span><span class="p">(</span><span class="n">corner1</span><span class="p">,</span><span class="n">corner2</span><span class="p">);</span>
  
  <span class="c1">//a bit-wise set for reasoning about sets of corners</span>
  <span class="kt">uint32_t</span> <span class="n">corner_set</span><span class="p">;</span>
  
  <span class="c1">//note that we can use the range-based for loop for cubelib, if using it from C++11</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">face</span> <span class="p">:</span> <span class="n">cubelib_faces_on_edge</span><span class="p">[</span><span class="n">cubelib_get_edge_index</span><span class="p">(</span><span class="n">edge0</span><span class="p">)])</span>
  <span class="p">{</span>
    <span class="c1">//we can now iterate over the 2 faces that are adjacent to this edge.</span>
    
    <span class="c1">//get all the corners that touch these faces</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">corner</span> <span class="p">:</span> <span class="n">cubelib_corners_on_face</span><span class="p">[</span><span class="n">cubelib_get_face_index</span><span class="p">(</span><span class="n">face</span><span class="p">)])</span>
    <span class="p">{</span>
        <span class="n">corner_set</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cubelib_get_corner_index</span><span class="p">(</span><span class="n">corner</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="c1">//remove the original corners</span>
  <span class="n">corner_set</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="kt">uint32_t</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cubelib_get_corner_index</span><span class="p">(</span><span class="n">corner1</span><span class="p">));</span>
  <span class="n">corner_set</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="kt">uint32_t</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cubelib_get_corner_index</span><span class="p">(</span><span class="n">corner2</span><span class="p">));</span>
  
  <span class="c1">//print all the corners on the faces of edge0, aside from the corners of the edge itself</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">corner</span> <span class="p">:</span> <span class="n">cubelib_all_corners</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">corner_set</span> <span class="o">&gt;&gt;</span> <span class="n">cubelib_get_corner_index</span><span class="p">(</span><span class="n">corner</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">corner</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="reference-pages">
<h2>Reference pages:<a class="headerlink" href="#reference-pages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="cubelib-corner.html">cubelib_corner_t</a></li>
<li class="toctree-l1"><a class="reference internal" href="cubelib-direction.html">cubelib_direction_t</a></li>
<li class="toctree-l1"><a class="reference internal" href="cubelib-edge.html">cubelib_edge_t</a></li>
<li class="toctree-l1"><a class="reference internal" href="cubelib-face.html">cubelib_face_t</a></li>
</ul>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="index.html">corner-cases</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="cubelib-corner.html">cubelib_corner_t</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Azriel Fasten.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1.
    </div>
  </body>
</html>